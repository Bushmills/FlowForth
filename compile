#!/bin/bash -f
# description:  target compiler for the Automate threaded code VM.
# dependencies: apart from the VM, additionally needed files are:
#        primitives.list   -  a list of the VM code labels.
#        library.inc    -  extensions and cold start entry point.

# problems found:
#   empty lines with white spaces rather than just linefeeds cause compilation error

# bumping version number requires change to VM too:
# generated programs contain this version. VM compares it against its own version,
# which must be identical. This prevents execution of programs not compatible with
# the VM any longer or have never been.
# version is changed when VM, compiler or lib changes render programs incompatible.
# Otherwise is subversion bumped. VM doesn't check for subversion.
version="0.18"
subversion="1"
# 20201219ls 0.18.1  alias support added (multiple names to same xt in primitives.inc)
#        constant variable create @ ,   can be used in both host and compile mode
# 20201218ls 0.18.0  VM: added lshift rshift /mod */ . int slit type
#        VM and compile: renamed literal to dolit
#        compile: renamed lit to literal, factored literal parser,
#        added string literal detection and handling.
#        code file format has changed, as previous format was incompatible with literal strings containing spaces
# 20201218ls 0.17.1  compiler: changed colon to :
#        changed all flow control statements from _statement to STATEMENT
#        added include (include location defaults to directory of library)
#        allot directive fetches arg from hstack
#        interpret time literals are pushed to stack
#        compile time literals are compiled
#        added fail handler which aborts, contrasting with error which proceeds
#        added "immediate" directives which execute during compilation
#        added [ and ] to turn off and on compilation
#        added fulllisting directive, replacing former listing directive
#        former listing directive lists now only user program
#        test programs and library:
#        changed all flow control statements _statement to STATEMENT
#        changed all colon to :
#        removed all occurances of lit
# 20201217ls 0.17.0  compiler: added [tick] and execute.
#        VM: added execute primitive, speeded up program loading
# 20201217ls 0.16.2  detect number, no need for preceding them with lit
#        preparing removal of second symbol table
# 20201215ls 0.16.1  added literals. VM checks for code files matching.
#        removed bug with non-empty lines containing white space only.
#version=0.15"  # 20201214ls v0.15: added library, flow control.


# --- general settings ---
debugging=0

srcext="prog"                                               # source files default extension
codeext="code"                                              # compiler output files extension

base="$HOME/FlowForth"                                      # subdirectories relative to $base
primitives="$base/lib/primitives.inc"                       # location and name of primitives list
library="$base/lib/library.inc"                             # location and name of library



# --- data space ---
program="$1"

dp=0                                                        # initial compilation address
declare -a m                                                # memory
declare -A symbol                                           # symbol table (labels)
declare -a forwardrefs
declare -A directive                                        # non-code assembler directives
declare -A find                                             # word name to excecution token (primitive and hilevel) or code (runtime)
declare -A headerflag                                       # vehicle to remove one of those two seperate symbol tables.
immediate=1                                                 # precendence bit, "immediate"
declare -a h                                                # compile time data stack  (hoststack)
compiling=0                                                 # 0 or 1, depending on whether host compiles or interpretes
errors=0                                                    # error counter
fail=1                                                      # exit code for fail
success=0                                                   # exit code for success

# having written several times to get rid of seperate symbol lists -
# keeping those may actually not be a bad idea:
# rename them to  "interpreted" and "compiled", similar with what cmforth on Novix does.
# but name list "symbols" could go - it's only used for labels, of which exists only two:
# cold and end

# --- general subroutines and misc helpers ---

debug()  {
   (( debugging )) && {
      printf -- '--- debug: %s   %s\n' "${FUNCNAME[1]}" "$@"
   }
}


error()  {
   printf 'error: %s\n'  "$@" >&2
   [[ -z "$file" ]] || printf '%s\n' "file $file, line $line, columns $column: $l"
   (( errors++ ))
   output="/dev/null"                                       # prevent code generation
}

fail()  {
   error "$@"
   exit "$fail"
}

needs()     { error "${FUNCNAME[2]} needs $1"; }
needarg()   { needs "an argument" "$@"; }
needname()  { needs "a name argument"; }
needvalue() { needs "a value argument"; }
needfile()  { needs "a file name argument"; }



# ---
[[ -d "$base" ]] || fail "base directory ($base) not found or not accessable"
[[ -f "$primitives" ]] || fail "no primitives table"        # refuse execution without primitives
[[ -z "$program" ]] && fail "missing program name"          # refuse compilation without file name given
[[ "${program##*.}" == "$codeext" ]] &&                     # don't clobber source if extension matches code
   fail "source extension may not be $codeext"
[[ ! -f "$program" && -f "$program.$srcext" ]] &&           # conditionally append default source extension
   program+=".$srcext"
[[ -f "$program" ]] || fail "$program not found"
output="${program%.*}.$codeext"                             # change extension of output file
sources="$library $program"                                 # files included by compiler run


### --- subroutines ---

title()     { printf -- '--- %s ---\n' "$1"; }

hcompile()  {
debug "arg=$1"
   m[dp++]="$1"
}                                                           # "host compile", write arg into target program space

forwardref()  {                                             # by compiling the symbol name which can't yet be
   arg="$1"                                                 # resolved into target space, and adding the
   [[ -z "$arg" ]] && needarg                               # compilation address to a list of fwd refs,
   forwardrefs[${#forwardrefs[@]}]="$dp"                    # we can later hunt these references and resolve
   hcompile "$arg"                                          # them.
}

number()  {                                                 # is arg a valid number?
   local ref="$1"
   [[ -z "${ref//[0-9+-]/}" ]]                              # a bit simplistic, can be cheated easily
}

symbol()  {                                                 # is arg a defined symbol?
   local ref="$1"
   [[ -n "${symbol[$ref]}" ]]
}


# compile a ref, either resolve immediately, or as forward ref
href()  {
   ref="$1"
   if  symbol "$ref"; then hcompile "$ref"                  # hcompile if resolvable symbol
   elif  number "$ref"; then hcompile "$ref"                # hcompile if number
   else forwardref "$ref"                                   # forwardref if neither number nor resolvable symbol
   fi
}


hpush()  {
   hdepth="${#h[@]}"
   h[hdepth]="$1"
}

hpop()  {                                                   # host pop: move top element to variable tos
   hdepth="${#h[@]}"
   nos="$tos"                                               # not really nos:   first pop moves to tos.   next pop moved former tos to nos, makes current tos (which actually was nos) tos
   tos="${h[@]:0 -1}"
   unset "h[hdepth-1]"
}


spush()  {
   hdepth="${#s[@]}"
   s[hdepth]="$@"
debug "pushed [$@]"
}

spop()  {                                                   # host string pop: move top string stack element to tos
   hdepth="${#s[@]}"
   tos="${s[@]:0 -1}"
debug "popped [$tos]"
   unset "s[hdepth-1]"
}




### --- directives ---
# directives are meant to operate in interpret mode only, unless the precedence bit has been set.
# They never get compiled, but they may compile to target program as result of them being executed.
# that makes them akin to state smart, or "immediate", Forth words.
# It is meant to further blur the difference between "directives" and "words", which are compiled into target,
# partly by use of header flags. words, in contrast with directives, are never executed during compilation.

# $1 is name searched when running compile, $2 is bash function called when $1 is encountered in source
directive()  {
  last="$1"
  directive["$1"]="$2"
}

# directive immediate                                       # not much use as directive at this point
immediate()  {                                              # by flagging a directive as immediate, it will also be able to execute
#   (( headerflag["$last"] |= immediate ))                  # during compilation. Other directives won't be found during compilation.
   w="${headerflag["$last"]}"                               # "[" is a bit tricky to use as index for a hash:
   (( w |= immediate ))                                     # while the commented out version fails, avoiding to
   headerflag["$last"]="$w"                                 # index the array within a math expression works.
}





# --- host constants ---
directive "false" "false";    false()     { hpush "0"; }
directive "true"  "true";     true()      { hpush "-1"; }

# --- host stack directives ---

directive "dup"   "dup";      dup()       { hpush "${h[@]:0 -1}"; }
directive "drop"  "drop";     drop()      { hpop; }
directive "swap"  "swap";     swap()      { hpop; hpop; hpush "$nos"; hpush "$tos"; }
directive "over"  "over";     over()      { hpush "${h[@]:0 -2:1}"; }
directive "nip"   "nip";      nip()       { swap; drop; }
directive "tuck"  "tuck";     tuck()      { swap; over; }
directive "?dup"  "qdup";     qdup()      { hpop; (( tos )) && hpush "$tos"; }
directive "depth" "depth";    depth()     { hpush "${#h[@]}"; }
directive "2dup"  "twodup";   twodup()    { over; over; }
directive "2drop" "twodrop";  twodrop()   { drop; drop; }

directive "sdup"  "sdup" ;    sdup()      { spush "${s[@]:0 -1}"; }
directive "sdrop" "sdrop";    sdrop()     { spop; }



# --- host compares ---
directive "0="    "notzero";  notzero()   { hpop; hpush $((~tos)); }
directive "="     "equal";    equal()     { hpop; hpop; hpush $(( -(tos == nos) )); }
directive "<>"    "notequal"; notequal()  { equal; notzero; }
directive "<"     "less";     less()      { hpop; hpop; hpush $(( -(tos < nos) )); }
directive ">"     "more";     more()      { swap; less; }
directive "<="    "lessequal";lessequal() { more; notzero; }
directive ">="    "morezero"; moreequal() { less; notzero; }


# --- host (exec) bitwise logic directives
wrap=$(((1<<32)-1))
directive "and"   "and";      and()       { hpop; hpop; hpush $(( tos & nos )); }
directive "or"    "or";       or()        { hpop; hpop; hpush $(( tos | nos )); }
directive "xor"   "xor";      xor()       { hpop; hpop; hpush $(( tos ^ nos )); }
directive "invert" "invert";  invert()    { hpop; hpush $(( ~tos )); }
directive "lshift" "lshift";  lshift()    { hpop; hpop; hpush $(( (tos "<<" nos) & wrap )); }  # quotes circumvent geany colour highlighting from never finding a match, albeit quoting the operator, not the operands, looks a tad unconventional.
directive "rshift" "rshift";  rshift()    { hpop; hpop; hpush $(( (tos & wrap) >> nos )); }


# --- host (exec) memory access and allocation directives
directive "@"     "fetch";    fetch()     { hpop; hpush "${m[tos]}"; }
directive "!"     "store";    store()     { hpop; hpop; m[nos]="$tos"; }
directive "+!"    "plusstore";plusstore() { hpop; hpop; (( m[nos] += tos )); }
directive "allot" "allot";    allot()     { hpop; (( dp += tos )); }             # reserve a number of cells by advancing compilation pointer  # ( x -- )
directive "here"  "here";     here()      { hpush "$dp"; }                       # pushs current compilation address on host stack
directive ","     "comma";    comma()     { hpop; hcompile "$tos"; }


#  --- host (exec) arithmethics
directive "*/"    "starslash";starslash() { hpop; hpop; hdepth="${#h[@]}"; h[hdepth-1]="$(( h[hdepth-1] * tos / nos ))"; }
directive "/mod" "slashmod";  slashmod()  { hpop; hpop; hpush $(( tos % nos )); hpush $(( tos / nos )); }
directive "+"     "plus";     plus()      { hpop; hpop; hpush $(( tos + nos )); }
directive "1+"    "oneplus";  oneplus()   { hpop; hpush $(( tos + 1 )); }
directive "1-"    "oneminus"; oneminus()  { hpop; hpush $(( tos - 1 )); }
directive "-"     "minus";    minus()     { hpop; hpop; hpush $(( tos - nos )); }
directive "*"     "mul";      mul()       { hpush 1; starslash; }
directive "/"     "div";      div()       { slashmod; nip; }
directive "mod"   "mod";      mod()       { slashmod; drop; }
directive "negate" "negate";  negate()    { hpop; hpush $(( -tos )); }
directive "abs"   "abs";      abs()       { hpop; hpush $(( ${tos#-} )); }
directive "min"   "min";      min()       { hpop; hpop; (( nos < tos )) && hpush "$nos" || hpush "$tos"; }
directive "max"   "max";      max()       { hpop; hpop; (( nos > tos )) && hpush "$nos" || hpush "$tos"; }

directive "["     "[";        [()         { compiling=0; };  immediate     # suspend compilation, switch to interpretation
directive "]"     "]";        ]()         { compiling=1; }                 # switch to compilation

# --- output directives ---

directive "cr"    "cr";       cr()        { printf '\n'; }
directive "."     "dot";      dot()       { hpop; echo "$tos"; }
directive "type" "type";      type()      { spop; echo "$tos"; }



# --- host words defining directives ---

directive "label" "label"
label()  {
   [[ -z "$1" ]] && needname
   symbol["$1"]="$dp"                                       # just a name in $find, no runtime, no allocation
}


# i'd like to eliminate this maintaining two distinct lists of similar data.
header() {
   [[ -z "$1" ]] && needname
   find["$1"]="$dp"
   label "$1"
}


directive "create" "create"
create()  {                                                 # header with dovar runtime and no allocation
   [[ -z "$1" ]] && needname
   header "$1"
   hcompile "dovar"

   directive "$1" "$1"                                      # also add constant to host
   eval "function $1  { hpush "$dp"; }"
}


# variable foo                                              # create variable foo, initialized to 0
# variable foo 15                                           # create variable foo, initialized to 15
# variable foo bla                                          # create variable foo, initialized to symbol bla or forward reference
directive "variable" "variable"
variable()  {                                               # variable: dovar runtime with 1 cell allocated
   [[ -z "$1" ]] && needname
   create "$1"
   href "${2:-0}"
}


directive "constant" "constant"
constant()  {                                               # constant name value
   [[ -z "$1" ]] && needname
   [[ -z "$2" ]] && needvalue "$1"

   header "$1"
   hcompile "doconst"
   href "$2"

   directive "$1" "$1"                                      # also add constant to host
   eval "function $1  { hpush $2; }"
}




directive ":" ":"
:()  {
   [[ -z "$1" ]] && needname
   header "$1"                                              # create new header
   hcompile "nest"                                          # compile nest runtime
   ]                                                        # turn on compilation
}


directive ";" "semicolon"; immediate                        # immediate so it can be used to finish compiling a colon word
semicolon()  {
   hcompile "${find[unnest]}"                               # compile an unnest execution token
   [                                                        # turn off compilation
}


# --- flow control compiling directives ---

directive "begin" "BEGIN"; immediate
BEGIN()  {
   hpush "$dp"
}


directive "again" "AGAIN"; immediate
AGAIN()  {
   hcompile "${find[branch]}"
   comma
}


directive "until" "UNTIL"; immediate
UNTIL()  {
   hcompile "${find[branch0]}"
   comma
}


directive "while" "WHILE"; immediate
WHILE()  {
   hcompile "${find[branch0]}"
   hpush "$dp"
   hcompile 0
}


directive "repeat" "REPEAT"; immediate
REPEAT()  {
   hcompile "${find[branch]}"
   hpop; m[tos]=$((dp + 1))
   comma
}


directive "if" "IF"; immediate
IF()  { WHILE; }


directive "else" "ELSE"; immediate
ELSE()  {
   hcompile "${find[branch]}"
   hpop; m[tos]=$((dp + 1))
   hpush "$dp"; hcompile 0
}


directive "then" "THEN"; immediate
THEN()  {
   hpop; m[tos]="$dp"
}


# --- host not sorted yet ---


directive "sliteral" "sliteral"; immediate
sliteral() {
   (( compiling )) && {                                     # when compiling compile a string literal
      hcompile "${find[slit]}"
      spop
debug "tos=[$tos]"
      hcompile "$tos"
   }                                                        # otherwise simply leave item on stack
}


directive "literal" "literal"; immediate
literal() {
   (( compiling )) && {                                     # when compiling compile a literal
      hcompile "${find[dolit]}"
      comma
   }                                                        # otherwise simply leave item on stack
}


directive "[']" "[tick]"; immediate
[tick]() {                                                  # compile a literal (an in-code number)
   [[ -z "$1" ]] && needarg
   hpush "${find[$1]}"
   literal
}


# not well tested yet. seems to work
directive "include" "include"
include()  {
   local file
   [[ -z "$1" ]] && needfile
   file="${library%/*}/$1"
   [[ -f "$file" ]] || fail "no such file: $file"
   title "including $file"
   compilefile "$file"
}


tabulate()  {
   name="$1"
   value="$2"
   printf '%s:\t'  "$name"
   (( ${#name} < 7 )) && printf '\t'
   printf '%3d\n' "$value"
}

directive "symbols" "symbols"
symbols()  {
   title "symbols"
   for name in "${!symbol[@]}"; do
      tabulate "$name" "${symbol["$name"]}"
   done | sort -n -k2,2
   cr
}

directive "words" "words"
words()  {
   title "words"
   for name in "${!find[@]}"; do
      tabulate "$name" "${find["$name"]}"
   done | sort -nk 2,2
   cr
}


listingfromto()  {
   if (( ended )); then
      for ((from="$1"; from<"$2"; from++)); do
         [[ -z "${m[from]}" ]] ||
         printf '%d: %s\n' "$from" "${m[from]}"

         (( from == ${symbol[cold]}-1 )) &&
            printf '%s\n' "--- program starts here (run time library above) ---"
      done
      cr
   else
      error "invoke listing after end statement only"
   fi
}


directive "listing" "listing"
listing()  {
   title "listing"
   listingfromto "${symbol[cold]}" "$dp"
}


directive "fulllisting" "fulllisting"
fulllisting()  {
   title "full listing"
   listingfromto "0" "$dp"
}


# second pass patching in unresolved forward references
directive "end" "end"
end()  {
   label end                                                # resolves dictionary pointer forward ref
   (( ${#forwardrefs[@]} )) && {                            # unresolved reference, need second pass
      for ref in "${forwardrefs[@]}"; do
         l="${m[ref]}"                                      # read symbol from mem
         a="${symbol[$l]}"                                  # lookup its address
         [[ -z "$a" ]] && {
            error "unresolved symbol: $l"
         }
         m[ref]="$a"                                        # replace against value
      done
   }

   to="$dp"                                                 # write generated code to file
   {  for ((from=0; from<to; from++)); do
         o="${m[from]}"                                     # read next memory location
         printf '%s\n' "${o:-"-1"}"                         # replace unitialized locations with -1
      done
   } > $output                                              # write to file
   ended=1
}


# memory map of a .code file, as loaded into VM memory:
# addr   use
#   0    coldstart vector
#   1    compiler/library version (vm has its version in a variable,
#        so the program loader can check whether program and VM match.
#   2-?? system variables (labelled, reference by name)
#  ??-?? primitives (labelled, reference by name)
#  ??-?? run time library (included, labelled, reference by name)
#  ??-?? user program
#______  the next adress is first free address in user program space.
#  rubber banding memory allocation is possible, or simply static
#  allocation by modifying the the pointer to this address.
#  In fact does library have words to do so:
#     "here" returns that address,
#     "allot" modifies it.


# --- initialize memory with cold start vector and system variables
forwardref "cold"                                           # cold start vector at address 0
hcompile "$((10#${version//./}))"                           # store version number in address 1
variable dp end                                             # let target know where code ends


# --- compiler and interpret helpers
isdirective()  { [[ -n "${directive["$1"]}" ]]; }
isword()       { [[ -n "${find["$1"]}" ]]; }
isimmediate()  { (( ${headerflag["$1"]:=0} & immediate )); }


# interpret or compile lines containing literals
inline()  {
   local arg=($@)
#debug "args: [${arg[@]}]"
   if number "$arg"; then                                   # not an instruction. is it a number?
      hpush "$arg"
      literal
   elif [[ "${arg:0:1}" == '"' ]]; then
#debug "string literal $1 found"
      tos="${1#*'"'}"
      spush "${tos%%'"'*}"
      sliteral
   else
      if (( compiling )); then
#debug "forwardref $arg"                                    # not dealt with arg
         forwardref "$arg"                                  # compile as yet unresolved reference
      else
         error "not found: $arg"
      fi
   fi
}




# --- convert VM code labels to primitives ---
while read -r primitive aliases; do
   [[ -z "$primitive" ]] && continue
   [[ "${primitive:0:1}" == "#" ]] && continue
   find["$primitive"]="$dp"                                 # name -> execution token
   for alias in ${aliases%%#*}; do                          # add aliases: same xt, different name
      find["$alias"]="$dp"
   done
   hcompile "$primitive"                                    # compile xt
done < $primitives

### --- compiler ---
# change from linewise parsing to space seperated string parsing.
compilefile()  {
# these are locals because of include, which may be nested, clobbering those if they weren't declared local.
   local file="$1"														# file name
   local src																# array of all lines in source file
   local line																# processed line number
   local column															# count of chars already processed of current line
   local l																	# text on processed line
   local nlines															# $file line count
   [[ -f "$file" ]] && {
      readarray -t src < "$file"                            # this way of reading input,
		nlines="${#src[@]}"
      for ((line=0; line<nlines; line++)); do
			l="${src[line]}"
         stripped="${l//[[:space:]]/}"                   	# trim
         [[ -z "$stripped" ]] && continue                   # empty line
         [[ "${stripped:0:1}" == "#" ]] && continue         # comment line
         column="0"
			local arg=($l)
         if (( compiling )); then									# processes statements between : and semicolon, or after ]
			   if isword "$arg"; then                          # it's a word
			      hcompile "${find["$arg"]}"                   # compile execution token
			   elif isdirective "$arg"; then
			      if isimmediate "$arg"; then
			         arg[0]="${directive[$arg]}"
			         "${arg[@]}"                               # execute directive
			      else
			         error "interpret only: $arg"
			      fi
			   else
			     inline "$l"                                   # passing un-arrayed args, because it may contain string literal.
			   fi
			elif isdirective "$arg"; then								# deals with statements outside of colon and semicolon, or after [
			   arg[0]="${directive[$arg]}"
			   "${arg[@]}"                                     # execute directive with args
			else
			   inline "$l"
			fi
      done
   }
}



ended=0                                                     # detection for "end" in source
for file in $sources ; do
  compilefile "$file"
done

(( ended )) || end
(( errors )) || exit "$success"

many="${errors%1}"
printf '%s\n'  "compilation failed: $errors error${many:+s}"
exit "$fail"
